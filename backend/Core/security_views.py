from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.db import transaction
from django.utils import timezone
from django.contrib.auth import get_user_model
from django.db.models import Q, Count
import logging

from .social_models import (
    BlockedUser, SecurityLog, ActivityThrottle, ContentModerationQueue,
    SocialPost, PostComment, DetailedReview
)
from .notification_service import SocialNotificationService, SecurityMonitoringService
from .serializers import (
    BlockedUserSerializer, SecurityLogSerializer, 
    ContentModerationQueueSerializer, ReportContentSerializer
)

logger = logging.getLogger(__name__)
User = get_user_model()


class SecurityManagementViewSet(viewsets.ViewSet):
    """セキュリティ管理API"""
    permission_classes = [IsAuthenticated]
    
    @action(detail=False, methods=['post'])
    def block_user(self, request):
        """ユーザーをブロック"""
        try:
            blocked_user_id = request.data.get('user_id')
            reason = request.data.get('reason', '')
            severity_level = request.data.get('severity_level', 'low')
            expires_hours = request.data.get('expires_hours')  # 一時ブロック期限
            
            if not blocked_user_id:
                return Response(
                    {'error': 'ユーザーIDが必要です'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            try:
                blocked_user = User.objects.get(id=blocked_user_id)
            except User.DoesNotExist:
                return Response(
                    {'error': 'ユーザーが見つかりません'},
                    status=status.HTTP_404_NOT_FOUND
                )
            
            # 自分自身をブロックしようとした場合
            if blocked_user == request.user:
                return Response(
                    {'error': '自分自身をブロックすることはできません'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            with transaction.atomic():
                # 既存のブロック状態をチェック
                existing_block = BlockedUser.objects.filter(
                    blocker=request.user,
                    blocked=blocked_user,
                    is_active=True
                ).first()
                
                if existing_block:
                    return Response(
                        {'error': 'このユーザーは既にブロックされています'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
                
                # 期限設定
                expires_at = None
                if expires_hours:
                    expires_at = timezone.now() + timezone.timedelta(hours=expires_hours)
                
                # ブロック作成
                block = BlockedUser.objects.create(\n                    blocker=request.user,\n                    blocked=blocked_user,\n                    reason=reason,\n                    severity_level=severity_level,\n                    expires_at=expires_at\n                )\n                \n                # セキュリティログ記録\n                request.user.create_security_log(\n                    action=f'blocked_user_{blocked_user.id}',\n                    severity='info',\n                    details={\n                        'blocked_user_id': blocked_user.id,\n                        'blocked_username': blocked_user.username,\n                        'reason': reason,\n                        'severity_level': severity_level,\n                        'expires_at': expires_at.isoformat() if expires_at else None\n                    },\n                    ip_address=self._get_client_ip(request),\n                    user_agent=request.META.get('HTTP_USER_AGENT', '')\n                )\n                \n                # 既存のフレンド関係を削除\n                from .social_models import Friendship\n                Friendship.objects.filter(\n                    Q(requester=request.user, receiver=blocked_user) |\n                    Q(requester=blocked_user, receiver=request.user)\n                ).delete()\n                \n                logger.info(f\"User {request.user.id} blocked user {blocked_user.id}\")\n                \n                return Response({\n                    'message': 'ユーザーをブロックしました',\n                    'block_id': block.id,\n                    'expires_at': expires_at.isoformat() if expires_at else None\n                }, status=status.HTTP_201_CREATED)\n                \n        except Exception as e:\n            logger.error(f\"Block user failed: {str(e)}\")\n            return Response(\n                {'error': 'ブロック処理に失敗しました'},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n    \n    @action(detail=False, methods=['post'])\n    def unblock_user(self, request):\n        \"\"\"ユーザーのブロックを解除\"\"\"\n        try:\n            blocked_user_id = request.data.get('user_id')\n            \n            if not blocked_user_id:\n                return Response(\n                    {'error': 'ユーザーIDが必要です'},\n                    status=status.HTTP_400_BAD_REQUEST\n                )\n            \n            try:\n                blocked_user = User.objects.get(id=blocked_user_id)\n            except User.DoesNotExist:\n                return Response(\n                    {'error': 'ユーザーが見つかりません'},\n                    status=status.HTTP_404_NOT_FOUND\n                )\n            \n            with transaction.atomic():\n                block = BlockedUser.objects.filter(\n                    blocker=request.user,\n                    blocked=blocked_user,\n                    is_active=True\n                ).first()\n                \n                if not block:\n                    return Response(\n                        {'error': 'このユーザーはブロックされていません'},\n                        status=status.HTTP_400_BAD_REQUEST\n                    )\n                \n                block.is_active = False\n                block.save(update_fields=['is_active'])\n                \n                # セキュリティログ記録\n                request.user.create_security_log(\n                    action=f'unblocked_user_{blocked_user.id}',\n                    severity='info',\n                    details={\n                        'blocked_user_id': blocked_user.id,\n                        'blocked_username': blocked_user.username\n                    },\n                    ip_address=self._get_client_ip(request),\n                    user_agent=request.META.get('HTTP_USER_AGENT', '')\n                )\n                \n                logger.info(f\"User {request.user.id} unblocked user {blocked_user.id}\")\n                \n                return Response({\n                    'message': 'ブロックを解除しました'\n                }, status=status.HTTP_200_OK)\n                \n        except Exception as e:\n            logger.error(f\"Unblock user failed: {str(e)}\")\n            return Response(\n                {'error': 'ブロック解除に失敗しました'},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n    \n    @action(detail=False, methods=['get'])\n    def blocked_users(self, request):\n        \"\"\"ブロックしたユーザー一覧\"\"\"\n        try:\n            blocks = BlockedUser.objects.filter(\n                blocker=request.user,\n                is_active=True\n            ).select_related('blocked').order_by('-blocked_at')\n            \n            # 期限切れブロックの処理\n            expired_blocks = [block for block in blocks if block.is_expired()]\n            for block in expired_blocks:\n                block.unblock_if_expired()\n            \n            # 有効なブロック一覧を再取得\n            blocks = BlockedUser.objects.filter(\n                blocker=request.user,\n                is_active=True\n            ).select_related('blocked').order_by('-blocked_at')\n            \n            serializer = BlockedUserSerializer(blocks, many=True)\n            return Response(serializer.data)\n            \n        except Exception as e:\n            logger.error(f\"Get blocked users failed: {str(e)}\")\n            return Response(\n                {'error': 'ブロック一覧の取得に失敗しました'},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n    \n    @action(detail=False, methods=['get'])\n    def security_logs(self, request):\n        \"\"\"セキュリティログ一覧\"\"\"\n        try:\n            logs = SecurityLog.objects.filter(\n                user=request.user\n            ).order_by('-created_at')[:50]  # 最新50件\n            \n            serializer = SecurityLogSerializer(logs, many=True)\n            return Response(serializer.data)\n            \n        except Exception as e:\n            logger.error(f\"Get security logs failed: {str(e)}\")\n            return Response(\n                {'error': 'セキュリティログの取得に失敗しました'},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n    \n    @action(detail=False, methods=['post'])\n    def report_content(self, request):\n        \"\"\"コンテンツを報告\"\"\"\n        try:\n            content_type = request.data.get('content_type')  # 'post', 'comment', 'review'\n            content_id = request.data.get('content_id')\n            reason = request.data.get('reason')\n            description = request.data.get('description', '')\n            \n            if not all([content_type, content_id, reason]):\n                return Response(\n                    {'error': '必要な情報が不足しています'},\n                    status=status.HTTP_400_BAD_REQUEST\n                )\n            \n            # コンテンツの存在確認\n            content_object = None\n            if content_type == 'post':\n                try:\n                    content_object = SocialPost.objects.get(id=content_id)\n                except SocialPost.DoesNotExist:\n                    return Response(\n                        {'error': '投稿が見つかりません'},\n                        status=status.HTTP_404_NOT_FOUND\n                    )\n            elif content_type == 'comment':\n                try:\n                    content_object = PostComment.objects.get(id=content_id)\n                except PostComment.DoesNotExist:\n                    return Response(\n                        {'error': 'コメントが見つかりません'},\n                        status=status.HTTP_404_NOT_FOUND\n                    )\n            elif content_type == 'review':\n                try:\n                    content_object = DetailedReview.objects.get(id=content_id)\n                except DetailedReview.DoesNotExist:\n                    return Response(\n                        {'error': 'レビューが見つかりません'},\n                        status=status.HTTP_404_NOT_FOUND\n                    )\n            else:\n                return Response(\n                    {'error': '無効なコンテンツタイプです'},\n                    status=status.HTTP_400_BAD_REQUEST\n                )\n            \n            # 重複報告チェック\n            from django.contrib.contenttypes.models import ContentType\n            content_type_obj = ContentType.objects.get_for_model(content_object)\n            \n            existing_report = ContentModerationQueue.objects.filter(\n                reported_by=request.user,\n                content_type=content_type_obj,\n                object_id=content_object.id,\n                status__in=['pending', 'reviewing']\n            ).first()\n            \n            if existing_report:\n                return Response(\n                    {'error': 'このコンテンツは既に報告済みです'},\n                    status=status.HTTP_400_BAD_REQUEST\n                )\n            \n            with transaction.atomic():\n                # 報告を作成\n                report = ContentModerationQueue.objects.create(\n                    reported_by=request.user,\n                    content_type=content_type_obj,\n                    object_id=content_object.id,\n                    report_reason=reason,\n                    report_description=description\n                )\n                \n                # セキュリティログ記録\n                request.user.create_security_log(\n                    action=f'reported_content_{content_type}_{content_id}',\n                    severity='info',\n                    details={\n                        'content_type': content_type,\n                        'content_id': content_id,\n                        'reason': reason,\n                        'description': description\n                    },\n                    ip_address=self._get_client_ip(request),\n                    user_agent=request.META.get('HTTP_USER_AGENT', '')\n                )\n                \n                logger.info(f\"User {request.user.id} reported {content_type} {content_id}\")\n                \n                return Response({\n                    'message': 'コンテンツを報告しました',\n                    'report_id': report.id\n                }, status=status.HTTP_201_CREATED)\n                \n        except Exception as e:\n            logger.error(f\"Report content failed: {str(e)}\")\n            return Response(\n                {'error': 'コンテンツ報告に失敗しました'},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n    \n    @action(detail=False, methods=['get'])\n    def activity_status(self, request):\n        \"\"\"現在の活動制限状況\"\"\"\n        try:\n            # アカウント制限チェック\n            is_locked = False\n            locked_until = None\n            if request.user.locked_until:\n                if request.user.locked_until > timezone.now():\n                    is_locked = True\n                    locked_until = request.user.locked_until\n                else:\n                    # 期限切れの場合はクリア\n                    request.user.locked_until = None\n                    request.user.save(update_fields=['locked_until'])\n            \n            # アクティビティ制限チェック\n            throttles = ActivityThrottle.objects.filter(\n                user=request.user,\n                is_throttled=True\n            ).select_related('user')\n            \n            active_throttles = []\n            for throttle in throttles:\n                if throttle.is_active_throttle():\n                    active_throttles.append({\n                        'activity_type': throttle.activity_type,\n                        'throttled_until': throttle.throttled_until\n                    })\n            \n            return Response({\n                'is_locked': is_locked,\n                'locked_until': locked_until,\n                'active_throttles': active_throttles,\n                'suspicious_activity_count': request.user.suspicious_activity_count\n            })\n            \n        except Exception as e:\n            logger.error(f\"Get activity status failed: {str(e)}\")\n            return Response(\n                {'error': '活動状況の取得に失敗しました'},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n    \n    def _get_client_ip(self, request):\n        \"\"\"クライアントIPアドレスを取得\"\"\"\n        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')\n        if x_forwarded_for:\n            ip = x_forwarded_for.split(',')[0]\n        else:\n            ip = request.META.get('REMOTE_ADDR')\n        return ip\n\n\nclass ContentModerationViewSet(viewsets.ModelViewSet):\n    \"\"\"コンテンツモデレーション管理API（管理者用）\"\"\"\n    serializer_class = ContentModerationQueueSerializer\n    permission_classes = [IsAuthenticated]\n    \n    def get_queryset(self):\n        # 管理者のみアクセス可能\n        if not self.request.user.is_staff:\n            return ContentModerationQueue.objects.none()\n        \n        return ContentModerationQueue.objects.all().select_related(\n            'reported_by', 'assigned_to', 'reviewed_by', 'content_type'\n        ).order_by('-created_at')\n    \n    @action(detail=True, methods=['post'])\n    def assign_moderator(self, request, pk=None):\n        \"\"\"モデレーターを割り当て\"\"\"\n        try:\n            if not request.user.is_staff:\n                return Response(\n                    {'error': '権限がありません'},\n                    status=status.HTTP_403_FORBIDDEN\n                )\n            \n            report = self.get_object()\n            moderator_id = request.data.get('moderator_id')\n            \n            if moderator_id:\n                try:\n                    moderator = User.objects.get(id=moderator_id, is_staff=True)\n                except User.DoesNotExist:\n                    return Response(\n                        {'error': 'モデレーターが見つかりません'},\n                        status=status.HTTP_404_NOT_FOUND\n                    )\n            else:\n                moderator = request.user\n            \n            report.assigned_to = moderator\n            report.status = 'reviewing'\n            report.save(update_fields=['assigned_to', 'status'])\n            \n            return Response({'message': 'モデレーターを割り当てました'})\n            \n        except Exception as e:\n            logger.error(f\"Assign moderator failed: {str(e)}\")\n            return Response(\n                {'error': 'モデレーター割り当てに失敗しました'},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n    \n    @action(detail=True, methods=['post'])\n    def review_content(self, request, pk=None):\n        \"\"\"コンテンツのレビュー結果を記録\"\"\"\n        try:\n            if not request.user.is_staff:\n                return Response(\n                    {'error': '権限がありません'},\n                    status=status.HTTP_403_FORBIDDEN\n                )\n            \n            report = self.get_object()\n            action = request.data.get('action')  # 'approved', 'rejected', 'removed'\n            notes = request.data.get('notes', '')\n            \n            if action not in ['approved', 'rejected', 'removed']:\n                return Response(\n                    {'error': '無効なアクションです'},\n                    status=status.HTTP_400_BAD_REQUEST\n                )\n            \n            with transaction.atomic():\n                report.status = action\n                report.reviewed_by = request.user\n                report.reviewed_at = timezone.now()\n                report.review_notes = notes\n                report.save(update_fields=['status', 'reviewed_by', 'reviewed_at', 'review_notes'])\n                \n                # コンテンツ削除の場合\n                if action == 'removed':\n                    content_obj = report.content_object\n                    if content_obj:\n                        if hasattr(content_obj, 'is_active'):\n                            content_obj.is_active = False\n                            content_obj.save(update_fields=['is_active'])\n                        elif hasattr(content_obj, 'deleted_at'):\n                            content_obj.deleted_at = timezone.now()\n                            content_obj.save(update_fields=['deleted_at'])\n                \n                # 報告者への通知（承認/拒否の場合）\n                if action in ['approved', 'rejected']:\n                    SocialNotificationService.create_notification(\n                        user=report.reported_by,\n                        notification_type='report_reviewed',\n                        data={\n                            'report_id': report.id,\n                            'action': action,\n                            'content_type': report.content_type.model\n                        }\n                    )\n                \n                logger.info(f\"Content moderation completed: {report.id} -> {action}\")\n                \n                return Response({\n                    'message': f'コンテンツを{action}しました',\n                    'report_id': report.id\n                })\n                \n        except Exception as e:\n            logger.error(f\"Review content failed: {str(e)}\")\n            return Response(\n                {'error': 'コンテンツレビューに失敗しました'},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n    \n    @action(detail=False, methods=['get'])\n    def statistics(self, request):\n        \"\"\"モデレーション統計\"\"\"\n        try:\n            if not request.user.is_staff:\n                return Response(\n                    {'error': '権限がありません'},\n                    status=status.HTTP_403_FORBIDDEN\n                )\n            \n            stats = ContentModerationQueue.objects.aggregate(\n                total=Count('id'),\n                pending=Count('id', filter=Q(status='pending')),\n                reviewing=Count('id', filter=Q(status='reviewing')),\n                approved=Count('id', filter=Q(status='approved')),\n                rejected=Count('id', filter=Q(status='rejected')),\n                removed=Count('id', filter=Q(status='removed'))\n            )\n            \n            # 理由別統計\n            reason_stats = ContentModerationQueue.objects.values('report_reason').annotate(\n                count=Count('id')\n            ).order_by('-count')\n            \n            return Response({\n                'overall': stats,\n                'by_reason': list(reason_stats)\n            })\n            \n        except Exception as e:\n            logger.error(f\"Get moderation statistics failed: {str(e)}\")\n            return Response(\n                {'error': '統計情報の取得に失敗しました'},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )